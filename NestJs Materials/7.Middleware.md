## 1.中间件

- 中间件是在路由处理程序之前调用的函数。中间件函数可以访问应用程序请求-响应周期中的请求和响应对象，以及 next() 中间件函数。下一个中间件函数通常由名为 next 的变量表示。

### 1.1 app.module.ts

src\app.module.ts

```diff
+import { Module,NestModule, MiddlewareConsumer,RequestMethod } from '@nestjs/common';
import { AppController } from './app.controller';
import { DynamicConfigModule } from './dynamicConfig.module';
import { AppService } from './app.service';
+import { LoggerMiddleware } from './logger.middleware';
@Module({
    imports: [
        DynamicConfigModule.forRoot({
            apiKey:'456'
        })
    ],
    controllers: [AppController],
    providers: [AppService]
})
+export class AppModule implements NestModule {
+  configure(consumer: MiddlewareConsumer) {
+    consumer
+      .apply(LoggerMiddleware)
+      .forRoutes('config');
+      //.forRoutes({ path: 'config', method: RequestMethod.GET })
+  }
+}
```

### 1.2 logger.middleware.ts

src\logger.middleware.ts

```js
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log('LoggerMiddleware');
    next();
  }
}
```

### 1.3 app.controller.ts

src\app.controller.ts

```diff
import { Controller, Get, Inject } from '@nestjs/common'
@Controller()
export class AppController {
+   @Get('config')
+   getConfig(): string {
+     return `Config`;
+   }
}
```

### 1.4 common\index.ts

src\@nestjs\common\index.ts

```diff
export * from './module.decorator'
export * from './controller.decorator';
export * from './http-methods.decorator';
export * from './param.decorator';
export * from './injectable.decorator';
export * from './inject.decorator';
export * from './constants';
+export * from './middleware.interface';
+export * from './nest-module.interface';
+export * from './middleware-consumer.interface'
+export * from './request-method.enum';
```

### 1.5 middleware.interface.ts

src\@nestjs\common\middleware.interface.ts

```js
import { Request, Response, NextFunction } from 'express';
export interface NestMiddleware {
  use(req: Request, res: Response, next: NextFunction): any;
}
```

### 1.6 nest-module.interface.ts

src\@nestjs\common\nest-module.interface.ts

```js
import {MiddlewareConsumer} from './middleware-consumer.interface';
export interface NestModule {
    configure(consumer: MiddlewareConsumer): void;
}
```

### 1.7 middleware-consumer.interface.ts

src\@nestjs\common\middleware-consumer.interface.ts

```js
import { RequestMethod } from './request-method.enum';
export interface MiddlewareConsumer {
  apply(...middleware: (Function | any)[]): this;
  forRoutes(...routes: (string | { path: string; method: RequestMethod } | Function)[]): this;
}
```

### 1.8 request-method.enum.ts

src\@nestjs\common\request-method.enum.ts

```js
export enum RequestMethod {
    GET = 'GET',
    POST = 'POST',
    PUT = 'PUT',
    DELETE = 'DELETE',
    PATCH = 'PATCH',
    ALL = 'ALL',
    OPTIONS = 'OPTIONS',
    HEAD = 'HEAD',
}
```

### 1.9 nest-application.ts

src\@nestjs\core\nest-application.ts

```diff
import 'reflect-metadata';
import express, { Express, Request as ExpressRequest, Response as ExpressResponse, NextFunction } from 'express'
import { Logger } from "./logger";
import path from 'path'
import { INJECTED_TOKENS, DESIGN_PARAMTYPES } from '@nestjs/common'
+import { RequestMethod } from '@nestjs/common/request-method.enum';
import { defineModule } from '../common';
export class NestApplication {
    private readonly app: Express = express()
    private readonly providerInstances = new Map()
    private readonly globalProviders = new Set()
    private readonly moduleProviers = new Map()
+   private readonly middlewares = []
    constructor(protected readonly module) {
        this.app.use(express.json());
        this.app.use(express.urlencoded({ extended: true }));
        this.initProviders();
+       this.initMiddlewares();
    }
+   private initMiddlewares() {
+       this.module.prototype.configure?.(this);
+   }
+   apply(...middleware: (Function | any)[]): this {
+       this.middlewares.push(...middleware);
+       return this;
+   }
+   forRoutes(...routes: any[]): this {
+       for (const route of routes) {
+           for (const middleware of this.middlewares) {
+               const { routePath, routeMethod } = this.normalizeRouteInfo(route);
+               this.app.use(routePath, (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
+                   if ((routeMethod === RequestMethod.ALL || routeMethod === req.method)) {
+                       const middlewareInstance = new middleware();
+                       middlewareInstance.use(req, res, next);
+                   } else {
+                       next();
+                   }
+               });
+           }
+       }
+       return this;
+   }
+   private normalizeRouteInfo(route) {
+       let routePath = '';
+       let routeMethod = RequestMethod.ALL;
+       if (typeof route === 'string') {
+           routePath = route;
+       } else if ('path' in route) {
+           routePath = route.path;
+           routeMethod = route.method ?? RequestMethod.ALL;
+       }
+       routePath = path.posix.join('/', routePath);
+       return { routePath, routeMethod };
+   }
    initProviders() {
        const imports = Reflect.getMetadata('imports', this.module) ?? [];
        for (const importModule of imports) {
            if (importModule.module) {
                const { module, providers, exports } = importModule;
                defineModule(this.module, providers);
                Reflect.defineMetadata('providers', [...(module.providers || []), ...providers], module);
                Reflect.defineMetadata('exports', [...(module.exports || []), ...exports], module);
                this.registerProvidersFromModule(module, this.module);
            } else {
                this.registerProvidersFromModule(importModule, this.module);
            }
        }
        const providers = Reflect.getMetadata('providers', this.module) ?? [];
        for (const provider of providers) {
            this.addProvider(provider, this.module);
        }
    }
    private registerProvidersFromModule(module, ...parentModules) {
        const global = Reflect.getMetadata('global', module);
        const importedProviders = Reflect.getMetadata('providers', module) ?? [];
        const exports = Reflect.getMetadata('exports', module) ?? [];
        for (const exportToken of exports) {
            if (this.isModule(exportToken)) {
                this.registerProvidersFromModule(exportToken, module, ...parentModules);
            } else {
                const provider = importedProviders.find(provider => provider === exportToken || provider.provide == exportToken);
                if (provider) {
                    [module, ...parentModules].forEach(module => {
                        this.addProvider(provider, module, global);
                    });
                }
            }
        }
    }
    private isModule(exportToken) {
        return exportToken && exportToken instanceof Function && Reflect.getMetadata('isModule', exportToken);
    }
    addProvider(provider, module, global = false) {
        const providers = global ? this.globalProviders : (this.moduleProviers.get(module) || new Set());
        if (!this.moduleProviers.has(module)) {
            this.moduleProviers.set(module, providers);
        }
        const injectToken = provider.provide ?? provider;
        if (this.providerInstances.has(injectToken)) {
            if (!providers.has(injectToken)) {
                providers.add(injectToken);
            }
            return;
        }
        if (provider.provide && provider.useClass) {
            const Clazz = provider.useClass;
            const dependencies = this.resolveDependencies(Clazz);
            const value = new Clazz(...dependencies);
            this.providerInstances.set(provider.provide, value);
            providers.add(provider.provide);
        } else if (provider.provide && provider.useValue) {
            this.providerInstances.set(provider.provide, provider.useValue);
            providers.add(provider.provide);
        } else if (provider.provide && provider.useFactory) {
            const inject = provider.inject ?? [];
            const injectedValues = inject.map(injectToken => this.getProviderByToken(injectToken, module));
            const value = provider.useFactory(...injectedValues);
            this.providerInstances.set(provider.provide, value);
            providers.add(provider.provide);
        } else {
            const dependencies = this.resolveDependencies(provider);
            const value = new provider(...dependencies);
            this.providerInstances.set(provider, value);
            providers.add(provider);
        }
    }
    use(middleware) {
        this.app.use(middleware);
    }
    private getProviderByToken = (injectedToken, module) => {
        if (this.moduleProviers.get(module)?.has(injectedToken) || this.globalProviders.has(injectedToken)) {
            return this.providerInstances.get(injectedToken);
        } else {
            return null;
        }
    }
    private resolveDependencies(Clazz) {
        const injectedTokens = Reflect.getMetadata(INJECTED_TOKENS, Clazz) ?? [];
        const constructorParams = Reflect.getMetadata(DESIGN_PARAMTYPES, Clazz) ?? [];
        return constructorParams.map((param, index) => {
            const module = Reflect.getMetadata('module', Clazz);
            return this.getProviderByToken(injectedTokens[index] ?? param, module);
        });
    }
    async init() {
        const controllers = Reflect.getMetadata('controllers', this.module) || [];
        Logger.log(`AppModule dependencies initialized`, 'InstanceLoader');
        for (const Controller of controllers) {
            const dependencies = this.resolveDependencies(Controller);
            const controller = new Controller(...dependencies);
            const prefix = Reflect.getMetadata('prefix', Controller) || '/';
            Logger.log(`${Controller.name} {${prefix}}`, 'RoutesResolver');
            const controllerPrototype = Controller.prototype;
            for (const methodName of Object.getOwnPropertyNames(controllerPrototype)) {
                const method = controllerPrototype[methodName];
                const httpMethod = Reflect.getMetadata('method', method);
                const pathMetadata = Reflect.getMetadata('path', method);
                const redirectUrl = Reflect.getMetadata('redirectUrl', method);
                const redirectStatusCode = Reflect.getMetadata('redirectStatusCode', method);
                const statusCode = Reflect.getMetadata('statusCode', method);
                const headers = Reflect.getMetadata('headers', method) ?? [];
                if (!httpMethod) continue;
                const routePath = path.posix.join('/', prefix, pathMetadata)
                this.app[httpMethod.toLowerCase()](routePath, async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
                    const args = this.resolveParams(controller, methodName, req, res, next);
                    const result = await method.call(controller, ...args);
                    if (result?.url) {
                        return res.redirect(result.statusCode || 302, result.url);
                    }
                    if (redirectUrl) {
                        return res.redirect(redirectStatusCode || 302, redirectUrl);
                    }
                    if (statusCode) {
                        res.statusCode = statusCode;
                    } else if (httpMethod === 'POST') {
                        res.statusCode = 201;
                    }
                    const responseMetadata = this.getResponseMetadata(controller, methodName);
                    if (!responseMetadata || (responseMetadata?.data?.passthrough)) {
                        headers.forEach(({ name, value }) => {
                            res.setHeader(name, value);
                        });
                        res.send(result);
                    }
                })
                Logger.log(`Mapped {${routePath}, ${httpMethod}} route`, 'RoutesResolver');
            }
        }
        Logger.log(`Nest application successfully started`, 'NestApplication');
    }
    private getResponseMetadata(controller, methodName) {
        const paramsMetaData = Reflect.getMetadata(`params`, controller, methodName) ?? [];
        return paramsMetaData.filter(Boolean).find((param) =>
            param.key === 'Response' || param.key === 'Res' || param.key === 'Next');
    }
    private resolveParams(instance: any, methodName: string, req: ExpressRequest, res: ExpressResponse, next: NextFunction) {
        const paramsMetaData = Reflect.getMetadata(`params`, instance, methodName) ?? [];
        return paramsMetaData.map((paramMetaData) => {
            const { key, data, factory } = paramMetaData;
            const ctx = {
                swithToHttp: () => ({
                    getRequest: () => req,
                    getResponse: () => req,
                    getNext: () => next,
                })
            }
            switch (key) {
                case "Request":
                case "Req":
                    return req;
                case "Query":
                    return data ? req.query[data] : req.query;
                case "Headers":
                    return data ? req.headers[data] : req.headers;
                case 'Session':
                    return data ? req.session[data] : req.session;
                case 'Ip':
                    return req.ip;
                case 'Param':
                    return data ? req.params[data] : req.params;
                case 'Body':
                    return data ? req.body[data] : req.body;
                case "Response":
                case "Res":
                    return res;
                case "Next":
                    return next;
                case "DecoratorFactory":
                    return factory(data, ctx);
                default:
                    return null;
            }
        })
    }
    async listen(port) {
        await this.init();
        this.app.listen(port, () => {
            Logger.log(`Application is running on http://localhost:${port}`, 'NestApplication');
        });
    }
}
```

## 2.依赖注入

- Nest 中间件完全支持依赖注入。与提供者和控制器一样，它们能够注入依赖项，这些依赖项在同一模块中可用。与往常一样，这是通过 constructor 完成的。

### 2.1 logger.middleware.ts

src\logger.middleware.ts

```diff
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
+import { AppService } from './app.service';
@Injectable()
export class LoggerMiddleware implements NestMiddleware {
+ constructor(private appService:AppService){}
  use(req: Request, res: Response, next: NextFunction) {
+   console.log('LoggerMiddleware',this.appService.getConfig());
    next();
  }
}
```

### 2.2 module.decorator.ts

src\@nestjs\common\module.decorator.ts

```diff
import 'reflect-metadata';
interface ModuleMetadata{
  controllers?:Function[];
  providers?:any[];
  exports?:any[];
  imports?:any[];
}
export function Module(metadata:ModuleMetadata):ClassDecorator{
    return (target:Function)=>{
      Reflect.defineMetadata('isModule',true,target);
      defineModule(target,metadata.controllers);
      Reflect.defineMetadata('controllers',metadata.controllers,target);
      defineModule(target,metadata.providers??[]);
      Reflect.defineMetadata('providers',metadata.providers,target);
      Reflect.defineMetadata('exports',metadata.exports,target);
      Reflect.defineMetadata('imports',metadata.imports,target);
    }
}
+export function defineModule(nestModule,targets){
+ (Array.isArray(targets)?targets:[targets]).filter(Boolean).forEach(target=>Reflect.defineMetadata('module',nestModule,target));
+}
export function Global(){
  return (target:Function)=>{
    Reflect.defineMetadata('global',true,target);
  }
}
export interface DynamicModule extends ModuleMetadata {
  module: Function;
}
```

### 2.3 nest-application.ts

src\@nestjs\core\nest-application.ts

```diff
import 'reflect-metadata';
import express, { Express, Request as ExpressRequest, Response as ExpressResponse, NextFunction } from 'express'
import { Logger } from "./logger";
import path from 'path'
import { INJECTED_TOKENS, DESIGN_PARAMTYPES } from '@nestjs/common'
import { RequestMethod } from '@nestjs/common/request-method.enum';
import { defineModule } from '../common';
export class NestApplication {
    private readonly app: Express = express()
    private readonly providerInstances = new Map()
    private readonly globalProviders = new Set()
    private readonly moduleProviers = new Map()
    private readonly middlewares = []
    constructor(protected readonly module) {
        this.app.use(express.json());
        this.app.use(express.urlencoded({ extended: true }));
        this.initProviders();
        this.initMiddlewares();
    }
    private initMiddlewares() {
        this.module.prototype.configure?.(this);
    }
    apply(...middleware: (Function | any)[]): this {
        this.middlewares.push(...middleware);
        return this;
    }
    forRoutes(...routes: any[]): this {
        for (const route of routes) {
            for (const middleware of this.middlewares) {
                const { routePath, routeMethod } = this.normalizeRouteInfo(route);
                this.app.use(routePath, (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
                    if ((routeMethod === RequestMethod.ALL || routeMethod === req.method)) {
+                       defineModule(this.module, middleware);
+                       const dependencies = this.resolveDependencies(middleware);
+                       const middlewareInstance = new middleware(...dependencies);
                        middlewareInstance.use(req, res, next);
                    } else {
                        next();
                    }
                });
            }
        }
        return this;
    }
    private normalizeRouteInfo(route) {
        let routePath = '';
        let routeMethod = RequestMethod.ALL;
        if (typeof route === 'string') {
            routePath = route;
        } else if ('path' in route) {
            routePath = route.path;
            routeMethod = route.method ?? RequestMethod.ALL;
        }
        routePath = path.posix.join('/', routePath);
        return { routePath, routeMethod };
    }
    initProviders() {
        const imports = Reflect.getMetadata('imports', this.module) ?? [];
        for (const importModule of imports) {
            if (importModule.module) {
                const { module, providers, exports } = importModule;
                defineModule(this.module, providers);
                Reflect.defineMetadata('providers', [...(module.providers || []), ...providers], module);
                Reflect.defineMetadata('exports', [...(module.exports || []), ...exports], module);
                this.registerProvidersFromModule(module, this.module);
            } else {
                this.registerProvidersFromModule(importModule, this.module);
            }
        }
        const providers = Reflect.getMetadata('providers', this.module) ?? [];
        for (const provider of providers) {
            this.addProvider(provider, this.module);
        }
    }
    private registerProvidersFromModule(module, ...parentModules) {
        const global = Reflect.getMetadata('global', module);
        const importedProviders = Reflect.getMetadata('providers', module) ?? [];
        const exports = Reflect.getMetadata('exports', module) ?? [];
        for (const exportToken of exports) {
            if (this.isModule(exportToken)) {
                this.registerProvidersFromModule(exportToken, module, ...parentModules);
            } else {
                const provider = importedProviders.find(provider => provider === exportToken || provider.provide == exportToken);
                if (provider) {
                    [module, ...parentModules].forEach(module => {
                        this.addProvider(provider, module, global);
                    });
                }
            }
        }
    }
    private isModule(exportToken) {
        return exportToken && exportToken instanceof Function && Reflect.getMetadata('isModule', exportToken);
    }
    addProvider(provider, module, global = false) {
        const providers = global ? this.globalProviders : (this.moduleProviers.get(module) || new Set());
        if (!this.moduleProviers.has(module)) {
            this.moduleProviers.set(module, providers);
        }
        const injectToken = provider.provide ?? provider;
        if (this.providerInstances.has(injectToken)) {
            if (!providers.has(injectToken)) {
                providers.add(injectToken);
            }
            return;
        }
        if (provider.provide && provider.useClass) {
            const Clazz = provider.useClass;
            const dependencies = this.resolveDependencies(Clazz);
            const value = new Clazz(...dependencies);
            this.providerInstances.set(provider.provide, value);
            providers.add(provider.provide);
        } else if (provider.provide && provider.useValue) {
            this.providerInstances.set(provider.provide, provider.useValue);
            providers.add(provider.provide);
        } else if (provider.provide && provider.useFactory) {
            const inject = provider.inject ?? [];
            const injectedValues = inject.map(injectToken => this.getProviderByToken(injectToken, module));
            const value = provider.useFactory(...injectedValues);
            this.providerInstances.set(provider.provide, value);
            providers.add(provider.provide);
        } else {
            const dependencies = this.resolveDependencies(provider);
            const value = new provider(...dependencies);
            this.providerInstances.set(provider, value);
            providers.add(provider);
        }
    }
    use(middleware) {
        this.app.use(middleware);
    }
    private getProviderByToken = (injectedToken, module) => {
        if (this.moduleProviers.get(module)?.has(injectedToken) || this.globalProviders.has(injectedToken)) {
            return this.providerInstances.get(injectedToken);
        } else {
            return null;
        }
    }
    private resolveDependencies(Clazz) {
        const injectedTokens = Reflect.getMetadata(INJECTED_TOKENS, Clazz) ?? [];
        const constructorParams = Reflect.getMetadata(DESIGN_PARAMTYPES, Clazz) ?? [];
        return constructorParams.map((param, index) => {
            const module = Reflect.getMetadata('module', Clazz);
            return this.getProviderByToken(injectedTokens[index] ?? param, module);
        });
    }
    async init() {
        const controllers = Reflect.getMetadata('controllers', this.module) || [];
        Logger.log(`AppModule dependencies initialized`, 'InstanceLoader');
        for (const Controller of controllers) {
            const dependencies = this.resolveDependencies(Controller);
            const controller = new Controller(...dependencies);
            const prefix = Reflect.getMetadata('prefix', Controller) || '/';
            Logger.log(`${Controller.name} {${prefix}}`, 'RoutesResolver');
            const controllerPrototype = Controller.prototype;
            for (const methodName of Object.getOwnPropertyNames(controllerPrototype)) {
                const method = controllerPrototype[methodName];
                const httpMethod = Reflect.getMetadata('method', method);
                const pathMetadata = Reflect.getMetadata('path', method);
                const redirectUrl = Reflect.getMetadata('redirectUrl', method);
                const redirectStatusCode = Reflect.getMetadata('redirectStatusCode', method);
                const statusCode = Reflect.getMetadata('statusCode', method);
                const headers = Reflect.getMetadata('headers', method) ?? [];
                if (!httpMethod) continue;
                const routePath = path.posix.join('/', prefix, pathMetadata)
                this.app[httpMethod.toLowerCase()](routePath, async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
                    const args = this.resolveParams(controller, methodName, req, res, next);
                    const result = await method.call(controller, ...args);
                    if (result?.url) {
                        return res.redirect(result.statusCode || 302, result.url);
                    }
                    if (redirectUrl) {
                        return res.redirect(redirectStatusCode || 302, redirectUrl);
                    }
                    if (statusCode) {
                        res.statusCode = statusCode;
                    } else if (httpMethod === 'POST') {
                        res.statusCode = 201;
                    }
                    const responseMetadata = this.getResponseMetadata(controller, methodName);
                    if (!responseMetadata || (responseMetadata?.data?.passthrough)) {
                        headers.forEach(({ name, value }) => {
                            res.setHeader(name, value);
                        });
                        res.send(result);
                    }
                })
                Logger.log(`Mapped {${routePath}, ${httpMethod}} route`, 'RoutesResolver');
            }
        }
        Logger.log(`Nest application successfully started`, 'NestApplication');
    }
    private getResponseMetadata(controller, methodName) {
        const paramsMetaData = Reflect.getMetadata(`params`, controller, methodName) ?? [];
        return paramsMetaData.filter(Boolean).find((param) =>
            param.key === 'Response' || param.key === 'Res' || param.key === 'Next');
    }
    private resolveParams(instance: any, methodName: string, req: ExpressRequest, res: ExpressResponse, next: NextFunction) {
        const paramsMetaData = Reflect.getMetadata(`params`, instance, methodName) ?? [];
        return paramsMetaData.map((paramMetaData) => {
            const { key, data, factory } = paramMetaData;
            const ctx = {
                swithToHttp: () => ({
                    getRequest: () => req,
                    getResponse: () => req,
                    getNext: () => next,
                })
            }
            switch (key) {
                case "Request":
                case "Req":
                    return req;
                case "Query":
                    return data ? req.query[data] : req.query;
                case "Headers":
                    return data ? req.headers[data] : req.headers;
                case 'Session':
                    return data ? req.session[data] : req.session;
                case 'Ip':
                    return req.ip;
                case 'Param':
                    return data ? req.params[data] : req.params;
                case 'Body':
                    return data ? req.body[data] : req.body;
                case "Response":
                case "Res":
                    return res;
                case "Next":
                    return next;
                case "DecoratorFactory":
                    return factory(data, ctx);
                default:
                    return null;
            }
        })
    }
    async listen(port) {
        await this.init();
        this.app.listen(port, () => {
            Logger.log(`Application is running on http://localhost:${port}`, 'NestApplication');
        });
    }
}
```

## 3.路由通配符

- 模式路由也是支持的。例如，星号用作通配符，将匹配任何字符组合

### 3.1 app.module.ts

src\app.module.ts

```diff
import { Module,NestModule, MiddlewareConsumer,RequestMethod } from '@nestjs/common';
import { AppController } from './app.controller';
import { DynamicConfigModule } from './dynamicConfig.module';
import { AppService } from './app.service';
import { LoggerMiddleware } from './logger.middleware';
@Module({
    imports: [
        DynamicConfigModule.forRoot({
            apiKey:'456'
        })
    ],
    controllers: [AppController],
    providers: [AppService]
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      //.forRoutes('config');
      //.forRoutes({ path: 'config', method: RequestMethod.GET })
+     .forRoutes('ab*de');
  }
}
```

### 3.2 app.controller.ts

src\app.controller.ts

```diff
import { Controller, Get, Inject } from '@nestjs/common'
@Controller()
export class AppController {
  @Get('config')
  getConfig(): string {
    return `Config`;
  }
+ @Get('abcde')
+ abcde(): string {
+   return `abcde`;
+ }
}
```

## 4.排除路由

- 有时我们想要排除某些路由不应用中间件。我们可以使用 exclude() 方法轻松排除某些路由。此方法可以接受单个字符串、多个字符串或标识要排除的路由的 RouteInfo 对象

### 4.1 app.module.ts

src\app.module.ts

```diff
import { Module,NestModule, MiddlewareConsumer,RequestMethod } from '@nestjs/common';
import { AppController } from './app.controller';
import { DynamicConfigModule } from './dynamicConfig.module';
import { AppService } from './app.service';
import { LoggerMiddleware } from './logger.middleware';
@Module({
    imports: [
        DynamicConfigModule.forRoot({
            apiKey:'456'
        })
    ],
    controllers: [AppController],
    providers: [AppService]
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      //.forRoutes('config');
      //.forRoutes({ path: 'config', method: RequestMethod.GET })
      //.forRoutes('ab*de')
+     .exclude(
+      { path: '/app/config', method: RequestMethod.GET },
+    )
+    .forRoutes(AppController);
  }
}
```

### 4.2 app.controller.ts

src\app.controller.ts

```diff
import { Controller, Get } from '@nestjs/common'
+@Controller('app')
export class AppController {
  @Get('config')
  getConfig(): string {
    return `Config`;
  }
  @Get('abcde')
  abcde(): string {
    return `abcde`;
  }
}
```

### 4.3 middleware-consumer.interface.ts

src\@nestjs\common\middleware-consumer.interface.ts

```diff
import { RequestMethod } from './request-method.enum';
export interface MiddlewareConsumer {
  apply(...middleware: (Function | any)[]): this;
  forRoutes(...routes: (string | { path: string; method: RequestMethod } | Function)[]): this;
+ exclude(...routes: (string | { path: string; method: RequestMethod } | Function)[]): this;
}
```

### 4.4 nest-application.ts

src\@nestjs\core\nest-application.ts

```diff
import 'reflect-metadata';
import express, { Express, Request as ExpressRequest, Response as ExpressResponse, NextFunction } from 'express'
import { Logger } from "./logger";
import path from 'path'
import { INJECTED_TOKENS, DESIGN_PARAMTYPES } from '@nestjs/common'
import { RequestMethod } from '@nestjs/common/request-method.enum';
import { defineModule } from '../common';
export class NestApplication {
    private readonly app: Express = express()
    private readonly providerInstances = new Map()
    private readonly globalProviders = new Set()
    private readonly moduleProviers = new Map()
    private readonly middlewares = []
+   private readonly excludedRoutes = []
    constructor(protected readonly module) {
        this.app.use(express.json());
        this.app.use(express.urlencoded({ extended: true }));
        this.initProviders();
        this.initMiddlewares();
    }
+   exclude(...routes: any[]): this {
+       this.excludedRoutes.push(...routes);
+       return this;
+   }
    private initMiddlewares() {
        this.module.prototype.configure?.(this);
    }
    apply(...middleware: (Function | any)[]): this {
        this.middlewares.push(...middleware);
        return this;
    }
+   private isExcluded(reqPath: string, method: RequestMethod): boolean {
+       return this.excludedRoutes.some(route => {
+           const { routePath, routeMethod } = this.normalizeRouteInfo(route);
+           return routePath === reqPath && (routeMethod === RequestMethod.ALL || routeMethod === method);
+       });
+   }
    forRoutes(...routes: any[]): this {
        for (const route of routes) {
            for (const middleware of this.middlewares) {
                const { routePath, routeMethod } = this.normalizeRouteInfo(route);
                this.app.use(routePath, (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
+                   if (this.isExcluded(req.originalUrl, req.method)) {
+                       return next();
+                   }
                    if ((routeMethod === RequestMethod.ALL || routeMethod === req.method)) {
                        defineModule(this.module, middleware);
                        const dependencies = this.resolveDependencies(middleware);
                        const middlewareInstance = new middleware(...dependencies);
                        middlewareInstance.use(req, res, next);
                    } else {
                        next();
                    }
                });
            }
        }
        return this;
    }
    private normalizeRouteInfo(route) {
        let routePath = '';
        let routeMethod = RequestMethod.ALL;
        if (typeof route === 'string') {
            routePath = route;
        } else if ('path' in route) {
            routePath = route.path;
            routeMethod = route.method ?? RequestMethod.ALL;
+       } else if (route instanceof Function) {
+           routePath = Reflect.getMetadata('prefix', route);
+       }
        routePath = path.posix.join('/', routePath);
        return { routePath, routeMethod };
    }
    initProviders() {
        const imports = Reflect.getMetadata('imports', this.module) ?? [];
        for (const importModule of imports) {
            if (importModule.module) {
                const { module, providers, exports } = importModule;
                defineModule(this.module, providers);
                Reflect.defineMetadata('providers', [...(module.providers || []), ...providers], module);
                Reflect.defineMetadata('exports', [...(module.exports || []), ...exports], module);
                this.registerProvidersFromModule(module, this.module);
            } else {
                this.registerProvidersFromModule(importModule, this.module);
            }
        }
        const providers = Reflect.getMetadata('providers', this.module) ?? [];
        for (const provider of providers) {
            this.addProvider(provider, this.module);
        }
    }
    private registerProvidersFromModule(module, ...parentModules) {
        const global = Reflect.getMetadata('global', module);
        const importedProviders = Reflect.getMetadata('providers', module) ?? [];
        const exports = Reflect.getMetadata('exports', module) ?? [];
        for (const exportToken of exports) {
            if (this.isModule(exportToken)) {
                this.registerProvidersFromModule(exportToken, module, ...parentModules);
            } else {
                const provider = importedProviders.find(provider => provider === exportToken || provider.provide == exportToken);
                if (provider) {
                    [module, ...parentModules].forEach(module => {
                        this.addProvider(provider, module, global);
                    });
                }
            }
        }
    }
    private isModule(exportToken) {
        return exportToken && exportToken instanceof Function && Reflect.getMetadata('isModule', exportToken);
    }
    addProvider(provider, module, global = false) {
        const providers = global ? this.globalProviders : (this.moduleProviers.get(module) || new Set());
        if (!this.moduleProviers.has(module)) {
            this.moduleProviers.set(module, providers);
        }
        const injectToken = provider.provide ?? provider;
        if (this.providerInstances.has(injectToken)) {
            if (!providers.has(injectToken)) {
                providers.add(injectToken);
            }
            return;
        }
        if (provider.provide && provider.useClass) {
            const Clazz = provider.useClass;
            const dependencies = this.resolveDependencies(Clazz);
            const value = new Clazz(...dependencies);
            this.providerInstances.set(provider.provide, value);
            providers.add(provider.provide);
        } else if (provider.provide && provider.useValue) {
            this.providerInstances.set(provider.provide, provider.useValue);
            providers.add(provider.provide);
        } else if (provider.provide && provider.useFactory) {
            const inject = provider.inject ?? [];
            const injectedValues = inject.map(injectToken => this.getProviderByToken(injectToken, module));
            const value = provider.useFactory(...injectedValues);
            this.providerInstances.set(provider.provide, value);
            providers.add(provider.provide);
        } else {
            const dependencies = this.resolveDependencies(provider);
            const value = new provider(...dependencies);
            this.providerInstances.set(provider, value);
            providers.add(provider);
        }
    }
    use(middleware) {
        this.app.use(middleware);
    }
    private getProviderByToken = (injectedToken, module) => {
        if (this.moduleProviers.get(module)?.has(injectedToken) || this.globalProviders.has(injectedToken)) {
            return this.providerInstances.get(injectedToken);
        } else {
            return null;
        }
    }
    private resolveDependencies(Clazz) {
        const injectedTokens = Reflect.getMetadata(INJECTED_TOKENS, Clazz) ?? [];
        const constructorParams = Reflect.getMetadata(DESIGN_PARAMTYPES, Clazz) ?? [];
        return constructorParams.map((param, index) => {
            const module = Reflect.getMetadata('module', Clazz);
            return this.getProviderByToken(injectedTokens[index] ?? param, module);
        });
    }
    async init() {
        const controllers = Reflect.getMetadata('controllers', this.module) || [];
        Logger.log(`AppModule dependencies initialized`, 'InstanceLoader');
        for (const Controller of controllers) {
            const dependencies = this.resolveDependencies(Controller);
            const controller = new Controller(...dependencies);
            const prefix = Reflect.getMetadata('prefix', Controller) || '/';
            Logger.log(`${Controller.name} {${prefix}}`, 'RoutesResolver');
            const controllerPrototype = Controller.prototype;
            for (const methodName of Object.getOwnPropertyNames(controllerPrototype)) {
                const method = controllerPrototype[methodName];
                const httpMethod = Reflect.getMetadata('method', method);
                const pathMetadata = Reflect.getMetadata('path', method);
                const redirectUrl = Reflect.getMetadata('redirectUrl', method);
                const redirectStatusCode = Reflect.getMetadata('redirectStatusCode', method);
                const statusCode = Reflect.getMetadata('statusCode', method);
                const headers = Reflect.getMetadata('headers', method) ?? [];
                if (!httpMethod) continue;
                const routePath = path.posix.join('/', prefix, pathMetadata)
                this.app[httpMethod.toLowerCase()](routePath, async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
                    const args = this.resolveParams(controller, methodName, req, res, next);
                    const result = await method.call(controller, ...args);
                    if (result?.url) {
                        return res.redirect(result.statusCode || 302, result.url);
                    }
                    if (redirectUrl) {
                        return res.redirect(redirectStatusCode || 302, redirectUrl);
                    }
                    if (statusCode) {
                        res.statusCode = statusCode;
                    } else if (httpMethod === 'POST') {
                        res.statusCode = 201;
                    }
                    const responseMetadata = this.getResponseMetadata(controller, methodName);
                    if (!responseMetadata || (responseMetadata?.data?.passthrough)) {
                        headers.forEach(({ name, value }) => {
                            res.setHeader(name, value);
                        });
                        res.send(result);
                    }
                })
                Logger.log(`Mapped {${routePath}, ${httpMethod}} route`, 'RoutesResolver');
            }
        }
        Logger.log(`Nest application successfully started`, 'NestApplication');
    }
    private getResponseMetadata(controller, methodName) {
        const paramsMetaData = Reflect.getMetadata(`params`, controller, methodName) ?? [];
        return paramsMetaData.filter(Boolean).find((param) =>
            param.key === 'Response' || param.key === 'Res' || param.key === 'Next');
    }
    private resolveParams(instance: any, methodName: string, req: ExpressRequest, res: ExpressResponse, next: NextFunction) {
        const paramsMetaData = Reflect.getMetadata(`params`, instance, methodName) ?? [];
        return paramsMetaData.map((paramMetaData) => {
            const { key, data, factory } = paramMetaData;
            const ctx = {
                swithToHttp: () => ({
                    getRequest: () => req,
                    getResponse: () => req,
                    getNext: () => next,
                })
            }
            switch (key) {
                case "Request":
                case "Req":
                    return req;
                case "Query":
                    return data ? req.query[data] : req.query;
                case "Headers":
                    return data ? req.headers[data] : req.headers;
                case 'Session':
                    return data ? req.session[data] : req.session;
                case 'Ip':
                    return req.ip;
                case 'Param':
                    return data ? req.params[data] : req.params;
                case 'Body':
                    return data ? req.body[data] : req.body;
                case "Response":
                case "Res":
                    return res;
                case "Next":
                    return next;
                case "DecoratorFactory":
                    return factory(data, ctx);
                default:
                    return null;
            }
        })
    }
    async listen(port) {
        await this.init();
        this.app.listen(port, () => {
            Logger.log(`Application is running on http://localhost:${port}`, 'NestApplication');
        });
    }
}
```

## 5.函数式中间件

- 我们一直在使用的 LoggerMiddleware 类非常简单。它没有成员，没有附加方法，也没有依赖项。为什么我们不能只用一个简单的函数来定义它，而不是一个类？事实上，我们可以。这种类型的中间件称为函数式中间

### 5.1 app.module.ts

src\app.module.ts

```diff
import { Module,NestModule, MiddlewareConsumer,RequestMethod } from '@nestjs/common';
import { AppController } from './app.controller';
import { DynamicConfigModule } from './dynamicConfig.module';
import { AppService } from './app.service';
import { LoggerMiddleware } from './logger.middleware';
+import {logger} from './logger.function.middleware';
@Module({
    imports: [
        DynamicConfigModule.forRoot({
            apiKey:'456'
        })
    ],
    controllers: [AppController],
    providers: [AppService]
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      //.apply(LoggerMiddleware)
+     .apply(logger)
      //.forRoutes('config');
      //.forRoutes({ path: 'config', method: RequestMethod.GET })
      //.forRoutes('ab*de')
      .exclude(
       { path: '/app/config', method: RequestMethod.GET },
     )
     .forRoutes(AppController);
  }
}
```

### 5.2 logger.function.middleware.ts

src\logger.function.middleware.ts

```js
import { Request, Response, NextFunction } from 'express';
export function logger(req: Request, res: Response, next: NextFunction) {
  console.log(`logger.function.middleware...`);
  next();
};
```

### 5.3 src\@nestjs\core\nest-application.ts

src\@nestjs\core\nest-application.ts

```diff
import 'reflect-metadata';
import express, { Express, Request as ExpressRequest, Response as ExpressResponse, NextFunction } from 'express'
import { Logger } from "./logger";
import path from 'path'
import { INJECTED_TOKENS, DESIGN_PARAMTYPES } from '@nestjs/common'
import { RequestMethod } from '@nestjs/common/request-method.enum';
import { defineModule } from '../common';
export class NestApplication {
    private readonly app: Express = express()
    private readonly providerInstances = new Map()
    private readonly globalProviders = new Set()
    private readonly moduleProviers = new Map()
    private readonly middlewares = []
    private readonly excludedRoutes = []
    constructor(protected readonly module) {
        this.app.use(express.json());
        this.app.use(express.urlencoded({ extended: true }));
        this.initProviders();
        this.initMiddlewares();
    }
    exclude(...routes: any[]): this {
        this.excludedRoutes.push(...routes);
        return this;
    }
    private initMiddlewares() {
        this.module.prototype.configure?.(this);
    }
    apply(...middleware: (Function | any)[]): this {
        this.middlewares.push(...middleware);
        return this;
    }
    private isExcluded(reqPath: string, method: RequestMethod): boolean {
        return this.excludedRoutes.some(route => {
            const { routePath, routeMethod } = this.normalizeRouteInfo(route);
            return routePath === reqPath && (routeMethod === RequestMethod.ALL || routeMethod === method);
        });
    }
    forRoutes(...routes: any[]): this {
        for (const route of routes) {
            for (const middleware of this.middlewares) {
                const { routePath, routeMethod } = this.normalizeRouteInfo(route);
                this.app.use(routePath, (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
                    if (this.isExcluded(req.originalUrl, req.method)) {
                        return next();
                    }
                    if ((routeMethod === RequestMethod.ALL || routeMethod === req.method)) {
+                       if (typeof middleware === 'function' && middleware.prototype && 'use' in middleware.prototype) {
                            defineModule(this.module, middleware);
                            const dependencies = this.resolveDependencies(middleware);
                            const middlewareInstance = new middleware(...dependencies);
                            middlewareInstance.use(req, res, next);
+                       } else if (typeof middleware === 'function') {
+                           middleware(req, res, next);
+                       } else {
+                           next();
+                       }
                    } else {
                        next();
                    }
                });
            }
        }
        return this;
    }
    private normalizeRouteInfo(route) {
        let routePath = '';
        let routeMethod = RequestMethod.ALL;
        if (typeof route === 'string') {
            routePath = route;
        } else if ('path' in route) {
            routePath = route.path;
            routeMethod = route.method ?? RequestMethod.ALL;
        } else if (route instanceof Function) {
            routePath = Reflect.getMetadata('prefix', route);
        }
        routePath = path.posix.join('/', routePath);
        return { routePath, routeMethod };
    }
    initProviders() {
        const imports = Reflect.getMetadata('imports', this.module) ?? [];
        for (const importModule of imports) {
            if (importModule.module) {
                const { module, providers, exports } = importModule;
                defineModule(this.module, providers);
                Reflect.defineMetadata('providers', [...(module.providers || []), ...providers], module);
                Reflect.defineMetadata('exports', [...(module.exports || []), ...exports], module);
                this.registerProvidersFromModule(module, this.module);
            } else {
                this.registerProvidersFromModule(importModule, this.module);
            }
        }
        const providers = Reflect.getMetadata('providers', this.module) ?? [];
        for (const provider of providers) {
            this.addProvider(provider, this.module);
        }
    }
    private registerProvidersFromModule(module, ...parentModules) {
        const global = Reflect.getMetadata('global', module);
        const importedProviders = Reflect.getMetadata('providers', module) ?? [];
        const exports = Reflect.getMetadata('exports', module) ?? [];
        for (const exportToken of exports) {
            if (this.isModule(exportToken)) {
                this.registerProvidersFromModule(exportToken, module, ...parentModules);
            } else {
                const provider = importedProviders.find(provider => provider === exportToken || provider.provide == exportToken);
                if (provider) {
                    [module, ...parentModules].forEach(module => {
                        this.addProvider(provider, module, global);
                    });
                }
            }
        }
    }
    private isModule(exportToken) {
        return exportToken && exportToken instanceof Function && Reflect.getMetadata('isModule', exportToken);
    }
    addProvider(provider, module, global = false) {
        const providers = global ? this.globalProviders : (this.moduleProviers.get(module) || new Set());
        if (!this.moduleProviers.has(module)) {
            this.moduleProviers.set(module, providers);
        }
        const injectToken = provider.provide ?? provider;
        if (this.providerInstances.has(injectToken)) {
            if (!providers.has(injectToken)) {
                providers.add(injectToken);
            }
            return;
        }
        if (provider.provide && provider.useClass) {
            const Clazz = provider.useClass;
            const dependencies = this.resolveDependencies(Clazz);
            const value = new Clazz(...dependencies);
            this.providerInstances.set(provider.provide, value);
            providers.add(provider.provide);
        } else if (provider.provide && provider.useValue) {
            this.providerInstances.set(provider.provide, provider.useValue);
            providers.add(provider.provide);
        } else if (provider.provide && provider.useFactory) {
            const inject = provider.inject ?? [];
            const injectedValues = inject.map(injectToken => this.getProviderByToken(injectToken, module));
            const value = provider.useFactory(...injectedValues);
            this.providerInstances.set(provider.provide, value);
            providers.add(provider.provide);
        } else {
            const dependencies = this.resolveDependencies(provider);
            const value = new provider(...dependencies);
            this.providerInstances.set(provider, value);
            providers.add(provider);
        }
    }
    use(middleware) {
        this.app.use(middleware);
    }
    private getProviderByToken = (injectedToken, module) => {
        if (this.moduleProviers.get(module)?.has(injectedToken) || this.globalProviders.has(injectedToken)) {
            return this.providerInstances.get(injectedToken);
        } else {
            return null;
        }
    }
    private resolveDependencies(Clazz) {
        const injectedTokens = Reflect.getMetadata(INJECTED_TOKENS, Clazz) ?? [];
        const constructorParams = Reflect.getMetadata(DESIGN_PARAMTYPES, Clazz) ?? [];
        return constructorParams.map((param, index) => {
            const module = Reflect.getMetadata('module', Clazz);
            return this.getProviderByToken(injectedTokens[index] ?? param, module);
        });
    }
    async init() {
        const controllers = Reflect.getMetadata('controllers', this.module) || [];
        Logger.log(`AppModule dependencies initialized`, 'InstanceLoader');
        for (const Controller of controllers) {
            const dependencies = this.resolveDependencies(Controller);
            const controller = new Controller(...dependencies);
            const prefix = Reflect.getMetadata('prefix', Controller) || '/';
            Logger.log(`${Controller.name} {${prefix}}`, 'RoutesResolver');
            const controllerPrototype = Controller.prototype;
            for (const methodName of Object.getOwnPropertyNames(controllerPrototype)) {
                const method = controllerPrototype[methodName];
                const httpMethod = Reflect.getMetadata('method', method);
                const pathMetadata = Reflect.getMetadata('path', method);
                const redirectUrl = Reflect.getMetadata('redirectUrl', method);
                const redirectStatusCode = Reflect.getMetadata('redirectStatusCode', method);
                const statusCode = Reflect.getMetadata('statusCode', method);
                const headers = Reflect.getMetadata('headers', method) ?? [];
                if (!httpMethod) continue;
                const routePath = path.posix.join('/', prefix, pathMetadata)
                this.app[httpMethod.toLowerCase()](routePath, async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
                    const args = this.resolveParams(controller, methodName, req, res, next);
                    const result = await method.call(controller, ...args);
                    if (result?.url) {
                        return res.redirect(result.statusCode || 302, result.url);
                    }
                    if (redirectUrl) {
                        return res.redirect(redirectStatusCode || 302, redirectUrl);
                    }
                    if (statusCode) {
                        res.statusCode = statusCode;
                    } else if (httpMethod === 'POST') {
                        res.statusCode = 201;
                    }
                    const responseMetadata = this.getResponseMetadata(controller, methodName);
                    if (!responseMetadata || (responseMetadata?.data?.passthrough)) {
                        headers.forEach(({ name, value }) => {
                            res.setHeader(name, value);
                        });
                        res.send(result);
                    }
                })
                Logger.log(`Mapped {${routePath}, ${httpMethod}} route`, 'RoutesResolver');
            }
        }
        Logger.log(`Nest application successfully started`, 'NestApplication');
    }
    private getResponseMetadata(controller, methodName) {
        const paramsMetaData = Reflect.getMetadata(`params`, controller, methodName) ?? [];
        return paramsMetaData.filter(Boolean).find((param) =>
            param.key === 'Response' || param.key === 'Res' || param.key === 'Next');
    }
    private resolveParams(instance: any, methodName: string, req: ExpressRequest, res: ExpressResponse, next: NextFunction) {
        const paramsMetaData = Reflect.getMetadata(`params`, instance, methodName) ?? [];
        return paramsMetaData.map((paramMetaData) => {
            const { key, data, factory } = paramMetaData;
            const ctx = {
                swithToHttp: () => ({
                    getRequest: () => req,
                    getResponse: () => req,
                    getNext: () => next,
                })
            }
            switch (key) {
                case "Request":
                case "Req":
                    return req;
                case "Query":
                    return data ? req.query[data] : req.query;
                case "Headers":
                    return data ? req.headers[data] : req.headers;
                case 'Session':
                    return data ? req.session[data] : req.session;
                case 'Ip':
                    return req.ip;
                case 'Param':
                    return data ? req.params[data] : req.params;
                case 'Body':
                    return data ? req.body[data] : req.body;
                case "Response":
                case "Res":
                    return res;
                case "Next":
                    return next;
                case "DecoratorFactory":
                    return factory(data, ctx);
                default:
                    return null;
            }
        })
    }
    async listen(port) {
        await this.init();
        this.app.listen(port, () => {
            Logger.log(`Application is running on http://localhost:${port}`, 'NestApplication');
        });
    }
}
```

## 6.全局中间件

- 如果我们想一次性将中间件绑定到每个注册的路由，我们可以使用 INestApplication 实例提供的 use() 方法

### 6.1 main.ts

src\main.ts

```diff
import { NestFactory } from "@nestjs/core";
import {AppModule} from './app.module';
import session from 'express-session';
+import {logger} from './logger.function.middleware';
async function bootstrap(){
    const app = await NestFactory.create(AppModule);
    app.use(session({
        secret:'your-secret-key',
        resave:false,
        saveUninitialized:false,
        cookie:{maxAge:1000*60*60*24}
    }));
+   app.use(logger);
    await app.listen(3000);
}
bootstrap();
```